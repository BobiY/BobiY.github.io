---
layout: pages
title: import和require
category: js
---
<link rel="stylesheet" href="{{ site.baseurl }}/assets/style.css">
<link rel="stylesheet" href="{{ site.baseurl }}/css/helloWorld.css">
<h2>{{ page.title }}</h2>
<p> import 和 require 的纠葛</p>
<p>{{ page.date | date_to_string }}</p>
<h3>
    require 时代的模块
</h3>
<p>
    require(url) 最常见的地方时在 node 中导入模块使用，而模块化的思想，也是 node 的核心思想之一。这个思想使 javascript 构建大型应用成为可能。随后
    在浏览器端，就出现了 require 和 seajs 之类的模块化工具。在 ES6 标准还未出现之前，require 统治了模块化编程的思想。    
</p>
<p>
    node 的模块化遵循的使 CommonJS 规范，requireJS 遵循的是 AMD 规范，seaJS 遵循的是CMD规范，虽各有不同，但总是希望保持代码风格的统一。
</p>
{% highlight javascript %}
// a.js

//------- node -------
module.exports = {
    a:function(){},
    b:"XXX"
};

// ------- AMD or CMD -------
define(function(require,exports,module){
    module.exports = {
        a:function(){},
        b:"XXX"
    }
})
{% endhighlight %}
<p>
    从上面的代码可以看出，三种规范在编程风格上除了使用 define 函数包裹之外，其他部分都保持了统一。
</p>
{% highlight javascript %}
// b.js

// ------- node -------
var module = require("./a.js");
module.a();

// ------- AMD or CMD -------

define(function(require,exports,module){
    var module = require("./a.js");
    module.a();
})
{% endhighlight %}
<p>
    即使在使用上，三种规范的编程风格也是非常统一。
</p>

<h3>
    ES6 中的 module
</h3>
<p>
    ES6 中的模块化并没有采用以上的任何一种方式，而是自己规定了一套标准。
</p>
<h3>
    export 导出模块接口
</h3>
<p>
    export 的用发有些复杂，下面列举一些常用的用法：
</p>
{% highlight javascript %}
// a.js
export default function a(){}
export function c(){}

var b = "aaa";
export { b }; //这是 ES6 的写法，等价于 { b:b }
setTimeout( () => { b = "ddd" },1000 )
export const my = "my";
{% endhighlight %}
<p>
    在要导出的接口前添加 export指令，即可导出；但是在使用时也要注意导出的接口写法是否是正确，下面的这些就是一些错误的示例：
</p>
{% highlight javascript %}
export 1;
var a =100;
export a;
{% endhighlight %}
<p>
    export 在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出 1 没有任何意义，也不可能在 import 是有变量与之对应。
    export a 看着成立，但是 a 的值是一个数字，根本无法完成结构，因此必须写成 export { a } 的形式。即使 a 的值是一个 function。
    最后，建议你在文件的组后导出接口。 
</p>
{% highlight javascript %}
export {a,b,c,d}
{% endhighlight %}











